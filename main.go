package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"io/fs"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/packages"
)

const name = "const"

var (
	typ    = flag.String("type", "", "type name; must be set")
	output = flag.String("output", "", "output file name; default srcdir/<type_file>_const.go")
	tag    = flag.String("tag", "", "tag used to constant naming")
)

func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of "+name+":\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

func main() {
	log.SetPrefix(name + ": ")
	flag.Usage = Usage
	flag.Parse()

	typeName := *typ
	if len(typeName) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	args := flag.Args()
	outDirectory := outDir(args)

	pkg, files := ExtractPackageFiles(args)
	packageName := pkg.Name
	if len(files) == 0 {
		log.Printf("no src files in package %s", packageName)
		return
	}

	typeFile := findTypeFile(files, typeName, *tag)
	if typeFile == nil {
		log.Printf("type not found, %s", typeName)
		return
	}

	g := TagConstantsGenerator{}
	if g.generateFile(typeName, typeFile) {
		src := g.format()

		outputName := *output
		if outputName == "" {
			baseName := fmt.Sprintf("%s_const.go", typeName)
			outputName = filepath.Join(outDirectory, strings.ToLower(baseName))
		}
		const userWriteOtherRead = fs.FileMode(0644)
		if err := ioutil.WriteFile(outputName, src, userWriteOtherRead); err != nil {
			log.Fatalf("writing output: %s", err)
		}
	} else {
		log.Printf("no generated")
	}
}

func outDir(args []string) string {
	if len(args) > 0 && isDir(args[0]) {
		return args[0]
	}
	return "."
}

func isDir(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

type GoFile struct {
	file       *ast.File
	tags       map[tagName]map[fieldName]tagValue
	fieldNames []fieldName
	tagNames   []tagName
}

type TagConstantsGenerator struct {
	buf bytes.Buffer
}

func (g *TagConstantsGenerator) printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func (g *TagConstantsGenerator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		log.Printf("go src code formatting error: %s", err)
		return g.buf.Bytes()
	}
	return src
}

func ExtractPackageFiles(patterns []string) (*packages.Package, []*GoFile) {
	cfg := &packages.Config{
		Mode:  packages.NeedSyntax,
		Tests: false,
	}
	pkgs, err := packages.Load(cfg, patterns...)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("error: %d packages found", len(pkgs))
	}
	pkg := pkgs[0]
	return pkg, extractFiles(pkg)
}

func extractFiles(pkg *packages.Package) []*GoFile {
	syntax := pkg.Syntax

	files := make([]*GoFile, len(syntax))

	for i, file := range syntax {
		files[i] = &GoFile{file: file}
	}

	return files
}

func findTypeFile(files []*GoFile, typeName string, tag string) *GoFile {
	for _, file := range files {
		ast.Inspect(file.file, file.findTypeTags(typeName, tagName(tag)))

		if len(file.tagNames) > 0 && len(file.fieldNames) > 0 {
			return file
		}
	}
	return nil
}

func (g *TagConstantsGenerator) generateFile(typeName string, file *GoFile) bool {
	return g.generate(file.file.Name.Name, typeName, file.tagNames, file.fieldNames, file.tags)
}

func (g *TagConstantsGenerator) generate(
	packageName string, typeName string,
	tagNames []tagName, fieldNames []fieldName, tags map[tagName]map[fieldName]tagValue,
) bool {
	generated := false
	g.printf("// Code generated by '%s %s'; DO NOT EDIT.\n\n", name, strings.Join(os.Args[1:], " "))
	g.printf("package %s\n", packageName)

	g.printf("type(\n")
	for _, _tagName := range tagNames {
		constTypeName := getTypeName(typeName, _tagName)
		g.printf("%v %v\n", constTypeName, "string")
	}
	g.printf(")\n")

	g.printf("const(\n")
	for i, _tagName := range tagNames {
		if i > 0 {
			g.printf("\n")
		}
		for _, _fieldName := range fieldNames {
			tagFields := tags[_tagName]
			_tagValue, ok := tagFields[_fieldName]
			if ok {
				constTypeName := getTypeName(typeName, _tagName)
				constName := getConstName(typeName, _tagName, _fieldName)
				g.printf("%v=%v(\"%v\")\n", constName, constTypeName, _tagValue)
				generated = true
			}
		}
	}
	g.printf(")\n")
	return generated
}

func getConstName(typeName string, tag tagName, field fieldName) string {
	return typeName + "_" + string(tag) + "_" + string(field)
}

func getTypeName(typeName string, tag tagName) string {
	return typeName + "_" + string(tag)
}

type tagName string
type tagValue string
type fieldName string

func (f *GoFile) findTypeTags(typeName string, tag tagName) func(node ast.Node) bool {
	return func(node ast.Node) bool {
		var typeSpec *ast.TypeSpec
		var ok bool
		typeSpec, ok = node.(*ast.TypeSpec)
		if !ok {
			return true
		}

		rawType := typeSpec.Type
		n := typeSpec.Name.Name
		if typeName != "" && n != typeName {
			return true
		}

		var structType *ast.StructType
		structType, ok = rawType.(*ast.StructType)
		if !ok {
			return true
		}

		fields := structType.Fields.List

		tags := make(map[tagName]map[fieldName]tagValue)
		fieldNames := make([]fieldName, 0, len(fields))
		tagNames := make([]tagName, 0)

		for _, field := range fields {
			for _, _fieldName := range field.Names {
				tagsValues := field.Tag.Value
				fieldTagValues, fieldTagNames := parseTags(tagsValues)

				if tag != "" {
					_tagValue, ok := fieldTagValues[tag]
					if ok {
						fieldTagValues = map[tagName]tagValue{tag: _tagValue}
						fieldTagNames = []tagName{tag}
					} else {
						fieldTagNames = make([]tagName, 0)
					}
				}

				fldName := fieldName(_fieldName.Name)
				fieldNames = append(fieldNames, fldName)

				for _, fieldTagName := range fieldTagNames {
					fieldTagValue := fieldTagValues[fieldTagName]

					fieldsOfTag, ok := tags[fieldTagName]
					if !ok {
						fieldsOfTag = make(map[fieldName]tagValue)
						tags[fieldTagName] = fieldsOfTag
						tagNames = append(tagNames, fieldTagName)
					}

					fieldsOfTag[fldName] = fieldTagValue
				}
			}
		}

		if len(tags) > 0 {
			f.tags = tags
			f.fieldNames = fieldNames
			f.tagNames = tagNames
		}

		return false
	}
}

func parseTags(tags string) (map[tagName]tagValue, []tagName) {
	tagNames := make([]tagName, 0)
	tagValues := make(map[tagName]tagValue)

	var prevTagPos int
	tagValueLen := len(tags)
	for pos := 0; pos < tagValueLen; pos++ {
		character := rune(tags[pos])
		switch character {
		case '`', ',':
			prevTagPos = pos + 1
		case ':':
			_tagName := tagName(tags[prevTagPos:pos])

			//parse tagValue
			pos++

			character = rune(tags[pos])
			tagValueBorder := '"'
			findEndBorder := false
			if character == tagValueBorder {
				pos++
				findEndBorder = true
			}
			tagDelim := ','

			var endValuePos int
			for endValuePos = pos; endValuePos < tagValueLen; endValuePos++ {
				character = rune(tags[endValuePos])
				if findEndBorder && character == tagValueBorder {
					break
				} else if character == tagDelim {
					break
				}
			}

			_tagValue := tagValue(tags[pos:endValuePos])
			tagValues[_tagName] = _tagValue
			tagNames = append(tagNames, _tagName)
			prevTagPos = endValuePos
			pos = prevTagPos

		}
	}
	return tagValues, tagNames
}
